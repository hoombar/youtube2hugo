<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Blog Creator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.8em;
            font-weight: 300;
        }
        
        .header p {
            margin: 15px 0 0 0;
            opacity: 0.9;
            font-size: 1.2em;
        }
        
        .workflow-steps {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .workflow-step {
            background: rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        .step {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .step h2 {
            margin-top: 0;
            color: #333;
            font-size: 1.6em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }
        
        .input-group input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .input-group input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 14px 30px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        }
        
        .btn-generate {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            font-size: 18px;
            padding: 16px 40px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .section-card {
            background: #f9f9f9;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            margin-bottom: 25px;
            overflow: hidden;
        }
        
        .section-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .section-title {
            font-size: 1.4em;
            font-weight: 600;
            margin: 0;
        }
        
        .section-info {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .section-content {
            padding: 20px;
        }
        
        .section-preview {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }
        
        .section-preview h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .section-preview p {
            margin: 0;
            color: #666;
            line-height: 1.5;
        }
        
        .frames-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
            max-width: 100%;
        }
        
        .frame-item {
            border: 3px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
            width: 100%;
            max-width: none;
            min-width: 0;
        }
        
        .frame-item:hover {
            border-color: #667eea;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .frame-item.selected {
            border-color: #4CAF50;
            background: #f0fff0;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }
        
        .frame-item.disabled {
            opacity: 0.5;
            cursor: not-allowed !important;
        }
        
        .paragraph-section.max-reached {
            border: 2px solid #ff9800;
            background: #fff3e0;
        }
        
        .paragraph-counter {
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 12px;
            background: #e8f5e8;
            color: #2e7d32;
            font-size: 0.75em;
        }
        
        .paragraph-counter.max-reached {
            background: #ffebee;
            color: #c62828;
        }
        
        .frame-item img {
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9;
            object-fit: cover;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        
        .frame-info {
            font-size: 0.8em;
            color: #666;
        }
        
        .selection-summary {
            background: #e8f5e8;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .selection-summary h3 {
            margin: 0 0 15px 0;
            color: #2e7d32;
        }
        
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }
        
        .summary-item {
            text-align: center;
            background: white;
            padding: 15px;
            border-radius: 8px;
        }
        
        .summary-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #2e7d32;
        }
        
        .summary-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }
        
        .final-step {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin-top: 30px;
        }
        
        .final-step h3 {
            margin: 0 0 15px 0;
            font-size: 1.8em;
        }
        
        .final-step p {
            margin: 0 0 20px 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .result-panel {
            background: #e8f5e8;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
        }
        
        .result-panel h3 {
            margin: 0 0 15px 0;
            color: #2e7d32;
        }
        
        .result-panel a {
            color: #2e7d32;
            text-decoration: none;
            font-weight: bold;
        }
        
        .result-panel a:hover {
            text-decoration: underline;
        }
        
        .error {
            background: #ffebee;
            border: 2px solid #f44336;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .success {
            background: #e8f5e8;
            border: 2px solid #4CAF50;
            color: #2e7d32;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .drop-zone {
            border: 2px dashed #667eea;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            background: #f8f9ff;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .drop-zone.drag-over {
            border-color: #4CAF50;
            background: #f0fff0;
            transform: scale(1.02);
        }

        .drop-zone:hover {
            border-color: #4CAF50;
            background: #f0fff0;
        }

        .drop-zone-content {
            color: #667eea;
            font-size: 1.1em;
        }

        .drop-zone-content .icon {
            font-size: 2em;
            margin-bottom: 10px;
            display: block;
        }

        .drop-zone.drag-over .drop-zone-content {
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé¨ Hybrid Blog Creator</h1>
        <p>AI-powered content processing with manual frame selection</p>
        <div class="workflow-steps">
            <div class="workflow-step">üìù AI Content Processing</div>
            <div class="workflow-step">üñºÔ∏è Smart Frame Extraction</div>
            <div class="workflow-step">üëÜ Manual Frame Selection</div>
            <div class="workflow-step">üì∞ Blog Generation</div>
        </div>
    </div>

    <!-- Step 1: Video Input -->
    <div class="step" id="step1">
        <h2>üìπ Step 1: Video & Title</h2>

        <!-- Drag and Drop Zone -->
        <div class="drop-zone" id="video-drop-zone">
            <div class="drop-zone-content">
                <span class="icon">üé¨</span>
                <div><strong>Drag & drop a video file here</strong></div>
                <div style="margin-top: 5px; font-size: 0.9em; opacity: 0.8;">or click to browse files</div>
                <div style="margin-top: 10px; font-size: 0.8em; opacity: 0.6;">Supports: .mp4, .mov, .avi, .mkv, .webm</div>
            </div>
        </div>

        <!-- Helper info for full path -->
        <div style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 6px; padding: 12px; margin-bottom: 15px; font-size: 0.85em;">
            <strong>üí° Tip:</strong> To get the full path:
            <ul style="margin: 5px 0 0 20px; padding: 0;">
                <li><strong>Mac:</strong> Right-click file ‚Üí Hold Option ‚Üí "Copy [filename] as Pathname"</li>
                <li><strong>Windows:</strong> Shift + Right-click file ‚Üí "Copy as path"</li>
                <li><strong>Linux:</strong> Right-click file ‚Üí "Copy Location" or use terminal: <code>readlink -f filename</code></li>
            </ul>
        </div>

        <div class="input-group">
            <label for="video-path">Video File Path:</label>
            <input type="text" id="video-path" placeholder="/path/to/your/video.mp4">
        </div>
        <div class="input-group">
            <label for="blog-title">Blog Post Title:</label>
            <input type="text" id="blog-title" placeholder="Enter your blog post title">
        </div>
        <div class="input-group">
            <label for="frame-processing-mode">Frame Processing Mode:</label>
            <select id="frame-processing-mode" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                <option value="smart">Smart frame selection (slowest - analyzes quality, filters bad frames)</option>
                <option value="dedupe">Remove duplicates (medium - extracts every 1s, removes similar frames)</option>
                <option value="raw" selected>No processing (fastest - every 1 second, all frames)</option>
            </select>
            <small style="color: #666; display: block; margin-top: 5px;">
                Choose your balance between speed and frame quality filtering
            </small>
        </div>
        <button class="btn" onclick="processVideo()" id="process-btn">üöÄ Process Video & Create Sections</button>
        
        <div id="processing-status" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p><strong>AI Processing in Progress...</strong></p>
            <p><small>Extracting transcript ‚Üí Cleaning technical terms ‚Üí Creating sections ‚Üí Extracting frames</small></p>
        </div>
    </div>

    <!-- Step 2: Section Review & Frame Selection -->
    <div class="step" id="step2" style="display: none;">
        <h2>üéØ Step 2: Review Sections & Select Frames</h2>
        <p>Review the AI-generated sections and select the best frames for each one:</p>
        
        <div id="sections-container"></div>
        
        <div class="selection-summary" id="selection-summary" style="display: none;">
            <h3>üìä Frame Selection Summary</h3>
            <div class="summary-grid" id="summary-grid"></div>
        </div>
    </div>

    <!-- Step 3: Blog Generation -->
    <div class="final-step" id="step3" style="display: none;">
        <h3>üèóÔ∏è Step 3: Generate Blog Post</h3>
        <p>Ready to create your blog post with the selected frames!</p>
        <button class="btn btn-generate" onclick="generateBlog()" id="generate-btn">üì∞ Generate Final Blog Post</button>
        
        <div id="generation-status" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p>Generating your blog post with selected frames...</p>
        </div>
        
        <div id="final-result" class="result-panel" style="display: none;"></div>
    </div>

    <script>
        let sessionData = null;
        let selectedFrames = {};
        let updateTimeouts = {}; // For throttling DOM updates
        
        async function processVideo() {
            const videoPath = document.getElementById('video-path').value.trim();
            const title = document.getElementById('blog-title').value.trim();
            const processingMode = document.getElementById('frame-processing-mode').value;
            
            if (!videoPath) {
                alert('Please enter a video file path');
                return;
            }
            
            const processBtn = document.getElementById('process-btn');
            const processingStatus = document.getElementById('processing-status');
            
            // Update processing message based on mode
            const processingMessages = {
                'smart': 'AI Processing + Smart Frame Analysis...',
                'dedupe': 'AI Processing + Duplicate Removal...',
                'raw': 'AI Processing + Fast Frame Extraction...'
            };
            processingStatus.querySelector('p strong').textContent = processingMessages[processingMode];
            
            processBtn.disabled = true;
            processingStatus.style.display = 'block';
            
            try {
                const response = await fetch('/process_video', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        video_path: videoPath,
                        title: title,
                        processing_mode: processingMode
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to process video');
                }
                
                sessionData = await response.json();
                showSectionSelection();
                
            } catch (error) {
                showError('Error processing video: ' + error.message);
            } finally {
                processBtn.disabled = false;
                processingStatus.style.display = 'none';
            }
        }
        
        function showSectionSelection() {
            document.getElementById('step2').style.display = 'block';
            
            const container = document.getElementById('sections-container');
            container.innerHTML = '';
            
            // Check if AI processing might have failed
            if (sessionData.ai_processing_success === false) {
                const warningDiv = document.createElement('div');
                warningDiv.className = 'error';
                warningDiv.innerHTML = `
                    <strong>‚ö†Ô∏è AI Processing Warning</strong><br>
                    AI content formatting may have failed. You might see transcript-like content instead of properly formatted blog text.
                    This can happen due to Gemini API issues and is unrelated to your selected frame processing mode.
                    The generated blog will still work, but may need manual editing.
                `;
                container.appendChild(warningDiv);
            }
            
            sessionData.sections.forEach((section, sectionIndex) => {
                const frameData = sessionData.frames_data[sectionIndex];
                
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'section-card';
                
                // Create section header with transcript toggle
                const sectionHeaderHtml = `
                    <div class="section-header">
                        <div>
                            <div class="section-title">${section.title}</div>
                        </div>
                        <div class="section-info">
                            ${frameData.frame_count} frames | ${section.start_time.toFixed(1)}s - ${section.end_time.toFixed(1)}s
                            <br>
                            <label style="font-size: 0.8em; margin-top: 5px;">
                                <input type="checkbox" id="show-transcript-${sectionIndex}" onchange="toggleTranscript(${sectionIndex})">
                                Show original transcript
                            </label>
                        </div>
                    </div>
                    <div id="raw-transcript-${sectionIndex}" style="display: none; background: #f0f8ff; padding: 15px; margin: 0 20px 15px 20px; border-radius: 8px; border-left: 4px solid #4CAF50;">
                        <h6 style="margin: 0 0 10px 0; color: #2e7d32;">üéôÔ∏è Original Transcript (${section.start_time.toFixed(1)}s - ${section.end_time.toFixed(1)}s)</h6>
                        <p style="white-space: pre-wrap; line-height: 1.6; font-style: italic; color: #555;" id="transcript-text-${sectionIndex}">Loading transcript...</p>
                    </div>
                `;
                
                // Create paragraphs for frame selection
                let paragraphsHtml = '';
                const paragraphs = section.paragraphs || [section]; // Fallback if no paragraphs
                
                paragraphs.forEach((paragraph, paragraphIndex) => {
                    // Get frames for this paragraph's time range
                    const paragraphFrames = frameData.frames.filter(frame =>
                        frame.timestamp >= paragraph.start_time && frame.timestamp <= paragraph.end_time
                    );
                    
                    paragraphsHtml += `
                        <div class="paragraph-section" style="margin-bottom: 30px; padding: 15px; background: #fafafa; border-radius: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h5 style="margin: 0; color: #333;">üìù Paragraph ${paragraphIndex + 1}</h5>
                                <div style="font-size: 0.8em; color: #666;">
                                    <span>${paragraph.start_time.toFixed(1)}s - ${paragraph.end_time.toFixed(1)}s | ${paragraphFrames.length} frames</span>
                                    <br>
                                    <span id="paragraph-counter-${sectionIndex}-${paragraphIndex}" class="paragraph-counter">0/3 selected</span>
                                </div>
                            </div>
                            
                            <div class="paragraph-content" style="margin-bottom: 15px;">
                                <p style="white-space: pre-wrap; line-height: 1.6; margin: 0; font-size: 0.95em;">${paragraph.content}</p>
                            </div>
                            
                            <h6 style="margin: 10px 0 5px 0; color: #555;">üñºÔ∏è Select frames for this paragraph (max 3):</h6>
                            <div class="frames-grid">
                                ${paragraphFrames.map((frame, frameIndex) => {
                                    const globalFrameIndex = frameData.frames.findIndex(f => f.filename === frame.filename);
                                    return `
                                        <div class="frame-item" onclick="toggleFrameSelection(${sectionIndex}, ${globalFrameIndex}, this, ${paragraphIndex})">
                                            <img src="/images/${frame.filename}" alt="Frame at ${frame.timestamp.toFixed(1)}s">
                                            <div class="frame-info">${frame.timestamp.toFixed(1)}s</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            
                            ${paragraphFrames.length === 0 ? 
                                '<p style="color: #999; font-style: italic; margin: 10px 0;">No frames available for this time range</p>' : 
                                ''
                            }
                        </div>
                    `;
                });
                
                sectionDiv.innerHTML = sectionHeaderHtml + `
                    <div class="section-content">
                        <div id="formatted-content-${sectionIndex}">
                            ${paragraphsHtml}
                        </div>
                    </div>
                `;
                
                container.appendChild(sectionDiv);
                selectedFrames[sectionIndex] = [];
            });
            
            // Initialize paragraph counters
            updateParagraphCounters();
        }
        
        function toggleFrameSelection(sectionIndex, frameIndex, frameDiv, paragraphIndex) {
            const isSelected = selectedFrames[sectionIndex].includes(frameIndex);
            
            if (isSelected) {
                selectedFrames[sectionIndex] = selectedFrames[sectionIndex].filter(i => i !== frameIndex);
                frameDiv.classList.remove('selected');
            } else {
                // Check for 3-image limit per paragraph
                const currentParagraphFrames = getCurrentParagraphSelectedFrames(sectionIndex, paragraphIndex);
                if (currentParagraphFrames.length >= 3) {
                    alert('Maximum 3 images allowed per paragraph. Please deselect an image first.');
                    return;
                }
                
                selectedFrames[sectionIndex].push(frameIndex);
                frameDiv.classList.add('selected');
            }
            
            updateSelectionSummary();
            
            // Only update the specific paragraph that was affected
            updateSingleParagraphCounter(sectionIndex, paragraphIndex);
        }
        
        function getCurrentParagraphSelectedFrames(sectionIndex, paragraphIndex) {
            // Safety checks to prevent errors
            if (!sessionData || !sessionData.sections || !sessionData.sections[sectionIndex]) {
                return [];
            }
            
            const section = sessionData.sections[sectionIndex];
            if (!section.paragraphs || !section.paragraphs[paragraphIndex]) {
                return [];
            }
            
            const paragraph = section.paragraphs[paragraphIndex];
            const frameData = sessionData.frames_data && sessionData.frames_data[sectionIndex];
            if (!frameData || !frameData.frames) {
                return [];
            }
            
            // Safety check for selectedFrames
            if (!selectedFrames[sectionIndex]) {
                selectedFrames[sectionIndex] = [];
                return [];
            }
            
            // Get frames for this paragraph's time range (optimized)
            const paragraphFrameIndices = [];
            const frames = frameData.frames;
            const startTime = paragraph.start_time;
            const endTime = paragraph.end_time;
            
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                if (frame && frame.timestamp >= startTime && frame.timestamp <= endTime) {
                    paragraphFrameIndices.push(i);
                }
            }
            
            // Filter to only selected frames in this paragraph
            const selectedInSection = selectedFrames[sectionIndex];
            return selectedInSection.filter(frameIndex => 
                paragraphFrameIndices.includes(frameIndex)
            );
        }
        
        function updateParagraphCounters() {
            if (!sessionData) return;
            
            // Use requestAnimationFrame to prevent blocking the browser
            requestAnimationFrame(() => {
                sessionData.sections.forEach((section, sectionIndex) => {
                    const paragraphs = section.paragraphs || [section];
                    paragraphs.forEach((paragraph, paragraphIndex) => {
                        updateSingleParagraphCounter(sectionIndex, paragraphIndex);
                    });
                });
            });
        }
        
        function updateSingleParagraphCounter(sectionIndex, paragraphIndex) {
            const updateKey = `${sectionIndex}-${paragraphIndex}`;
            
            // Clear any existing timeout for this paragraph
            if (updateTimeouts[updateKey]) {
                clearTimeout(updateTimeouts[updateKey]);
            }
            
            // Throttle updates to prevent rapid DOM manipulation
            updateTimeouts[updateKey] = setTimeout(() => {
                const selectedCount = getCurrentParagraphSelectedFrames(sectionIndex, paragraphIndex).length;
                const counterElement = document.getElementById(`paragraph-counter-${sectionIndex}-${paragraphIndex}`);
                
                if (!counterElement) return;
                
                const paragraphSection = counterElement.closest('.paragraph-section');
                
                // Update counter text
                counterElement.textContent = `${selectedCount}/3 selected`;
                
                // Update counter styling
                if (selectedCount >= 3) {
                    counterElement.className = 'paragraph-counter max-reached';
                } else {
                    counterElement.className = 'paragraph-counter';
                }
                
                // Update paragraph section styling
                if (paragraphSection) {
                    if (selectedCount >= 3) {
                        paragraphSection.classList.add('max-reached');
                    } else {
                        paragraphSection.classList.remove('max-reached');
                    }
                }
                
                // Update frame disabled state for this paragraph only (throttled)
                updateFrameDisabledStateForParagraph(sectionIndex, paragraphIndex, selectedCount >= 3);
                
                // Clean up timeout reference
                delete updateTimeouts[updateKey];
            }, 50); // 50ms throttle
        }
        
        function updateFrameDisabledStateForParagraph(sectionIndex, paragraphIndex, isMaxReached) {
            // Safety checks to prevent infinite loops
            if (!sessionData || !sessionData.sections || !sessionData.frames_data) {
                return;
            }
            
            const section = sessionData.sections[sectionIndex];
            const frameData = sessionData.frames_data[sectionIndex];
            
            if (!section || !section.paragraphs || !section.paragraphs[paragraphIndex] || !frameData || !frameData.frames) {
                return;
            }
            
            const paragraph = section.paragraphs[paragraphIndex];
            
            // Limit the number of frames we process to prevent performance issues
            if (frameData.frames.length > 500) {
                console.warn('Too many frames to process efficiently, skipping disabled state update');
                return;
            }
            
            // Find the specific paragraph container more reliably
            const allParagraphContainers = document.querySelectorAll('.paragraph-section');
            if (paragraphIndex >= allParagraphContainers.length) return;
            
            const paragraphContainer = allParagraphContainers[paragraphIndex];
            if (!paragraphContainer) return;
            
            // Process frames in smaller batches to prevent blocking
            const frames = frameData.frames;
            const startTime = paragraph.start_time;
            const endTime = paragraph.end_time;
            const selectedInSection = selectedFrames[sectionIndex] || [];
            
            // Use requestAnimationFrame for non-blocking processing
            requestAnimationFrame(() => {
                let processedCount = 0;
                const maxProcessingLimit = 100; // Process at most 100 frames per paragraph to prevent lockup
                
                for (let frameIndex = 0; frameIndex < frames.length && processedCount < maxProcessingLimit; frameIndex++) {
                    const frame = frames[frameIndex];
                    if (!frame || frame.timestamp < startTime || frame.timestamp > endTime) {
                        continue;
                    }
                    
                    processedCount++;
                    
                    // Use a more specific selector within the paragraph container
                    const frameElement = paragraphContainer.querySelector(`[onclick*="toggleFrameSelection(${sectionIndex}, ${frameIndex}"]`);
                    const isSelected = selectedInSection.includes(frameIndex);
                    
                    if (frameElement && !isSelected) {
                        if (isMaxReached) {
                            frameElement.classList.add('disabled');
                            frameElement.style.pointerEvents = 'none';
                        } else {
                            frameElement.classList.remove('disabled');
                            frameElement.style.pointerEvents = 'auto';
                        }
                    }
                }
                
                if (processedCount >= maxProcessingLimit) {
                    console.warn(`Frame processing limit reached for paragraph ${paragraphIndex}, processed ${processedCount} frames`);
                }
            });
        }
        
        function toggleTranscript(sectionIndex) {
            const checkbox = document.getElementById(`show-transcript-${sectionIndex}`);
            const rawTranscript = document.getElementById(`raw-transcript-${sectionIndex}`);
            const formattedContent = document.getElementById(`formatted-content-${sectionIndex}`);
            
            // Safety checks to prevent errors
            if (!checkbox || !rawTranscript || !formattedContent) {
                console.error(`Toggle elements not found for section ${sectionIndex}`);
                return;
            }
            
            // Force checkbox state to be consistent with what we're about to show
            if (checkbox.checked) {
                // Show raw transcript, hide formatted
                rawTranscript.style.display = 'block';
                formattedContent.style.display = 'none';
                
                // Load transcript content if not already loaded
                const section = sessionData.sections[sectionIndex];
                const transcriptText = document.getElementById(`transcript-text-${sectionIndex}`);
                
                if (transcriptText && transcriptText.textContent === 'Loading transcript...') {
                    // Find transcript segments for this section's time range
                    const sectionTranscripts = sessionData.transcript_segments.filter(segment => 
                        segment.start_time >= section.start_time && segment.end_time <= section.end_time
                    );
                    
                    if (sectionTranscripts.length > 0) {
                        const transcriptContent = sectionTranscripts.map(segment => 
                            `[${segment.start_time.toFixed(1)}s] ${segment.text}`
                        ).join('\n\n');
                        transcriptText.textContent = transcriptContent;
                    } else {
                        transcriptText.textContent = 'No transcript segments found for this time range.';
                    }
                }
            } else {
                // Show formatted content, hide raw transcript
                rawTranscript.style.display = 'none';
                formattedContent.style.display = 'block';
            }
            
            // Force a small delay to ensure DOM has updated
            setTimeout(() => {
                // Double-check the state consistency
                const isTranscriptVisible = rawTranscript.style.display === 'block';
                if (checkbox.checked !== isTranscriptVisible) {
                    console.warn(`State mismatch detected for section ${sectionIndex}, correcting...`);
                    checkbox.checked = isTranscriptVisible;
                }
            }, 10);
        }
        
        function updateSelectionSummary() {
            const totalSelected = Object.values(selectedFrames).reduce((sum, frames) => sum + frames.length, 0);
            const sectionsWithSelections = Object.values(selectedFrames).filter(frames => frames.length > 0).length;
            
            if (totalSelected > 0) {
                document.getElementById('selection-summary').style.display = 'block';
                document.getElementById('step3').style.display = 'block';
                
                const summaryGrid = document.getElementById('summary-grid');
                summaryGrid.innerHTML = `
                    <div class="summary-item">
                        <div class="summary-value">${totalSelected}</div>
                        <div class="summary-label">Total Frames</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-value">${sectionsWithSelections}</div>
                        <div class="summary-label">Sections Covered</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-value">${(totalSelected / sectionsWithSelections || 0).toFixed(1)}</div>
                        <div class="summary-label">Avg per Section</div>
                    </div>
                `;
            } else {
                document.getElementById('selection-summary').style.display = 'none';
                document.getElementById('step3').style.display = 'none';
            }
        }
        
        async function generateBlog() {
            if (!sessionData) return;
            
            const generateBtn = document.getElementById('generate-btn');
            const generationStatus = document.getElementById('generation-status');
            
            generateBtn.disabled = true;
            generationStatus.style.display = 'block';
            
            // Prepare selections data with paragraph information
            const selectionsData = {
                session_id: sessionData.session_id,
                sections: sessionData.sections.map((section, sectionIndex) => {
                    const paragraphs = section.paragraphs || [section];
                    const frameData = sessionData.frames_data[sectionIndex];
                    const selectedFrameIndices = selectedFrames[sectionIndex] || [];
                    
                    // Group selected frames by paragraph
                    const framesWithParagraphs = selectedFrameIndices.map(frameIndex => {
                        const frame = frameData.frames[frameIndex];
                        const timestamp = frame.timestamp;
                        
                        // Find which paragraph this frame belongs to
                        let paragraphIndex = 0;
                        for (let i = 0; i < paragraphs.length; i++) {
                            if (timestamp >= paragraphs[i].start_time && timestamp <= paragraphs[i].end_time) {
                                paragraphIndex = i;
                                break;
                            }
                        }
                        
                        return {
                            filename: frame.filename,
                            timestamp: timestamp,
                            paragraph_index: paragraphIndex,
                            paragraph_start_time: paragraphs[paragraphIndex].start_time,
                            paragraph_end_time: paragraphs[paragraphIndex].end_time
                        };
                    });
                    
                    return {
                        section_title: section.title,
                        section_index: sectionIndex,
                        selected_frames: selectedFrameIndices.map(frameIndex => 
                            frameData.frames[frameIndex].filename
                        ),
                        frames_with_paragraphs: framesWithParagraphs
                    };
                })
            };
            
            try {
                // Save selections first
                const saveResponse = await fetch('/save_frame_selections', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(selectionsData)
                });
                
                if (!saveResponse.ok) {
                    throw new Error('Failed to save selections');
                }
                
                // Generate blog
                const blogResponse = await fetch('/generate_blog', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (!blogResponse.ok) {
                    const error = await blogResponse.json();
                    throw new Error(error.error || 'Failed to generate blog');
                }
                
                const result = await blogResponse.json();
                showFinalResult(result);
                
            } catch (error) {
                showError('Error generating blog: ' + error.message);
            } finally {
                generateBtn.disabled = false;
                generationStatus.style.display = 'none';
            }
        }
        
        function showFinalResult(result) {
            const resultDiv = document.getElementById('final-result');
            resultDiv.style.display = 'block';
            
            resultDiv.innerHTML = `
                <h3>üéâ Blog post generated successfully</h3>
            `;
        }
        
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.body.insertBefore(errorDiv, document.body.firstChild);
            
            setTimeout(() => errorDiv.remove(), 8000);
        }
        
        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.body.insertBefore(successDiv, document.body.firstChild);

            setTimeout(() => successDiv.remove(), 5000);
        }

        // Drag and Drop functionality
        function initializeDragAndDrop() {
            const dropZone = document.getElementById('video-drop-zone');
            const videoPathInput = document.getElementById('video-path');

            // Supported video file extensions
            const supportedExtensions = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.m4v', '.flv', '.wmv'];

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            // Highlight drop area when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            // Handle dropped files
            dropZone.addEventListener('drop', handleDrop, false);

            // Handle click to browse files
            dropZone.addEventListener('click', () => {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = supportedExtensions.join(',');
                fileInput.style.display = 'none';

                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        handleFile(e.target.files[0]);
                    }
                });

                document.body.appendChild(fileInput);
                fileInput.click();
                document.body.removeChild(fileInput);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function highlight(e) {
                dropZone.classList.add('drag-over');
            }

            function unhighlight(e) {
                dropZone.classList.remove('drag-over');
            }

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;

                if (files.length > 0) {
                    handleFile(files[0]);
                }
            }

            function handleFile(file) {
                const fileName = file.name.toLowerCase();
                const isVideoFile = supportedExtensions.some(ext => fileName.endsWith(ext));

                if (!isVideoFile) {
                    showError(`Unsupported file type. Please select a video file with one of these extensions: ${supportedExtensions.join(', ')}`);
                    return;
                }

                // Try to get the full path (works in Electron/desktop environments)
                let filePath = file.path || file.webkitRelativePath || file.name;

                // If we only have the filename, show a message asking user to manually enter the path
                if (filePath === file.name) {
                    videoPathInput.value = '';
                    videoPathInput.placeholder = `Please type or paste the full path to: ${file.name}`;
                    videoPathInput.focus();
                    showError(`Due to browser security, only the filename "${file.name}" was detected. Please manually enter the full file path in the input field below.`);
                    updateDropZoneWithFile(file.name, true); // true indicates path needed
                } else {
                    videoPathInput.value = filePath;
                    videoPathInput.placeholder = "/path/to/your/video.mp4";
                    showSuccess(`Video file selected: ${file.name}`);
                    updateDropZoneWithFile(file.name, false); // false indicates path is complete
                }
            }

            function updateDropZoneWithFile(fileName, needsPath = false) {
                const dropZoneContent = dropZone.querySelector('.drop-zone-content');

                if (needsPath) {
                    dropZoneContent.innerHTML = `
                        <span class="icon">‚ö†Ô∏è</span>
                        <div><strong>File detected:</strong></div>
                        <div style="margin-top: 5px; font-weight: bold; color: #ff9800;">${fileName}</div>
                        <div style="margin-top: 10px; font-size: 0.85em; color: #d84315;">‚¨áÔ∏è Please enter the full path below ‚¨áÔ∏è</div>
                        <div style="margin-top: 5px; font-size: 0.8em; opacity: 0.6;">Click here to select a different file</div>
                    `;
                } else {
                    dropZoneContent.innerHTML = `
                        <span class="icon">‚úÖ</span>
                        <div><strong>File selected:</strong></div>
                        <div style="margin-top: 5px; font-weight: bold; color: #2e7d32;">${fileName}</div>
                        <div style="margin-top: 10px; font-size: 0.8em; opacity: 0.6;">Click to select a different file</div>
                    `;
                }
            }
        }

        // Initialize drag and drop when the page loads
        document.addEventListener('DOMContentLoaded', initializeDragAndDrop);
    </script>
</body>
</html>